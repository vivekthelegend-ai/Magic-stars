<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Repulsion Particles</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  canvas {
    display: block;
  }
  video {
    display: none;
  }
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>

<!-- THREE JS -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= SCENE ================= */

let scene = new THREE.Scene();

let camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 6;

let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */

const COUNT = 50000;
let positions = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 10;
}

let geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

/* ðŸ”µ ROUND PARTICLES (IMPORTANT PART) */
let material = new THREE.PointsMaterial({
  size: 0.035,
  color: 0x00ccff,
  transparent: true,
  opacity: 0.9,
  depthWrite: false
});

let points = new THREE.Points(geometry, material);
scene.add(points);

/* ================= ANIMATION ================= */

function animate() {
  requestAnimationFrame(animate);
  points.rotation.y += 0.0007;
  renderer.render(scene, camera);
}
animate();

/* ================= HAND TRACKING ================= */

const video = document.getElementById("video");

const hands = new Hands({
  locateFile: file =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(onResults);

const cam = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
cam.start();

const repelRadius = 0.4;

function onResults(results) {
  if (!results.multiHandLandmarks) return;

  let hand = results.multiHandLandmarks[0][9];

  let hx = (hand.x - 0.5) * 6;
  let hy = -(hand.y - 0.5) * 6;

  let arr = geometry.attributes.position.array;

  for (let i = 0; i < COUNT; i++) {
    let idx = i * 3;
    let dx = arr[idx] - hx;
    let dy = arr[idx + 1] - hy;
    let dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < repelRadius) {
      arr[idx] += dx * 0.08;
      arr[idx + 1] += dy * 0.08;
    }
  }

  geometry.attributes.position.needsUpdate = true;
}

/* ================= RESIZE ================= */

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
